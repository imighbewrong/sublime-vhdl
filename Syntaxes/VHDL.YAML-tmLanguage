# [PackageDev] target_format: plist, ext: tmLanguage
comment: VHDL Bundle by Brian Padalino (ocnqnyvab@tznvy.pbz)
name: VHDL
scopeName: source.vhdl
fileTypes: [vhd, vhdl, vho]
uuid: 99A3EB51-FCCD-4EA4-A642-10C2E8B93112

patterns:
- include: '#block_processing'

- include: '#cleanup'

repository:
  association_element:
    patterns:
    - name: meta.block.association.vhdl
      begin: (?=['"a-zA-Z0-9])
      end: (,)|(?=\))
      endCaptures:
        '1': {name: punctuation.vhdl}
      patterns:
      - include: "#variable_pattern"
      - include: "#parenthetical_list"
      - include: "#cleanup"
  association_list:
    patterns:
    - name: meta.block.association_list.vhdl
      begin: \(
      beginCaptures:
        '0': {name: punctuation.vhdl}
      end: \)
      endCaptures:
        '0': {name: punctuation.vhdl}
      patterns:
      - include: "#association_element"
      - include: "#comments"
  architecture_pattern:
    patterns:
    - name: meta.block.architecture
      begin: |
        (?x)
        
        # The word architecture $1
        \b((?i:architecture))\s+
        
        # Followed up by a valid $3 or invalid identifier $4
        (([a-zA-z][a-zA-z0-9_]*)|(.+))(?=\s)\s+
        
        # The word of $5
        ((?i:of))\s+
        
        # Followed by a valid $7 or invalid identifier $8
        (([a-zA-Z][a-zA-Z0-9_]*)|(.+?))(?=\s*(?i:is))\b
                  
      beginCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: entity.name.type.architecture.begin.vhdl}
        '4': {name: invalid.illegal.invalid.identifier.vhdl}
        '5': {name: keyword.language.vhdl}
        '7': {name: entity.name.type.entity.reference.vhdl}
        '8': {name: invalid.illegal.invalid.identifier.vhdl}
      end: |
        (?x)
        # The word end $1
        \b((?i:end))
        
        # Optional word architecture $3
        (\s+((?i:architecture)))?
        
        # Optional same identifier $6 or illegal identifier $7
        (\s+((\3)|(.+?)))?
        
        # This will cause the previous to capture until just before the ; or $
        (?=\s*;)
                  
      endCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: keyword.language.vhdl}
        '6': {name: entity.name.type.architecture.end.vhdl}
        '7': {name: invalid.illegal.mismatched.identifier.vhdl}
      patterns:
      - include: '#concurrent_statement'
      - include: '#block_statement'

  attribute_list:
    patterns:
    - name: meta.block.attribute_list
      begin: \'\(
      beginCaptures:
        '0': {name: punctuation.vhdl}
      end: \)
      endCaptures:
        '0': {name: punctuation.vhdl}
      patterns:
      - include: '#parenthetical_list'
      - include: '#cleanup'

  block_statement:
    patterns:
    - name: meta.block.block_statement.vhdl
      begin: |
        (?x)
        # From the beginning of the line
        ^\s*
        
        (?:
          # Optional identifier $1
          ([a-zA-Z][a-zA-Z0-9_]*)
        
          # Colon $2
          \s*(:)\s*
        )?
        
        # The word block $3
        (?i:block\b)
                  
      beginCaptures:
        '1': {name: entity.name.section.block.begin.vhdl}
        '2': {name: punctuation.vhdl}
        '3': {name: keyword.language.vhdl}
      end: |
        (?x)
        # The word end $1
        (end)
        
        # the word block $2
        \s+(block)
        
        # Optional identifier $3 or invalid identifier $4
        (?:\s+(?:(\1)|(.+?)))?
        
        # Semicolon that ends it all
        \s*(;)
                  
      endCaptures:
        '1': {name: keyword.language.vhdl}
        '2': {name: keyword.language.vhdl}
        '3': {name: entity.name.section.block.end.vhdl}
        '4': {name: invalid.illegal.invalid.identifier.vhdl}
        '5': {name: punctuation.vhdl}
      patterns:
      - include: "#concurrent_statement"

  block_processing:
    patterns:
    - include: '#package_pattern'
    - include: '#package_body_pattern'
    - include: '#entity_pattern'
    - include: '#architecture_pattern'

  case_pattern:
    patterns:
    - name: meta.block.case.vhdl
      begin: |
        (?x)
        # Beginning of line ...
        ^\s*
        
        # Optional identifier ... $3 or invalid identifier $4
        (
          (
             ([a-zA-Z][a-zA-Z0-9_]*)
            |(.+?)
          )
          \s*:\s*
        )?
        
        # The word case $5
        \b((?i:case))\b
                  
      beginCaptures:
        '3': {name: entity.name.tag.case.begin.vhdl}
        '4': {name: invalid.illegal.invalid.identifier.vhdl}
        '5': {name: keyword.language.vhdl}
      end: |
        (?x)
        # The word end $1
        \b((?i:end))\s*
        
        # The word case $4 or invalid word $5
        (\s+(((?i:case))|(.*?)))
        
        # Optional identifier from before $8 or illegal $9
        (\s+((\2)|(.*?)))?
        
        # Ending with a semicolon
        (?=\s*;)
                  
      endCaptures:
        '1': {name: keyword.language.vhdl}
        '4': {name: keyword.language.vhdl}
        '5': {name: invalid.illegal.case.required.vhdl}
        '8': {name: entity.name.tag.case.end.vhdl}
        '9': {name: invalid.illegal.mismatched.identifier.vhdl}
      patterns:
      - include: '#control_patterns'
      - include: '#cleanup'

  cleanup:
    patterns:
    - include: '#comments'
    - include: '#constants_numeric'
    - include: '#strings'
    - include: '#attribute_list'
    - include: '#syntax_highlighting'

  comments:
    patterns:
    - name: comment.line.double-dash.vhdl
      match: --.*$\n?

  component_instantiation_pattern:
    patterns:
    - name: meta.block.component_instantiation.vhdl
      begin: |
        (?x)
        # From the beginning of the line ...
        ^\s*
        
        # Match a valid identifier $1
        ([a-zA-Z][a-zA-Z0-9_]*)
        
        # Colon! $2
        \s*(:)\s*
        
        # Another valid identifier $3
        ([a-zA-Z][a-zA-Z0-9_]*)\b
        
        # Make sure we are just the other word, or the beginning of
        # a generic or port mapping
        (?=\s*($|generic|port))
                  
      beginCaptures:
        '1': {name: entity.name.section.component_instantiation.vhdl}
        '2': {name: punctuation.vhdl}
        '3': {name: entity.name.tag.component.reference.vhdl}
      end: ;
      endCaptures:
        '0': {name: punctuation.vhdl}
      patterns:
      - include: '#generic_map_pattern'
      - include: '#port_map_pattern'
      - include: '#cleanup'

  component_pattern:
    patterns:
    - name: meta.block.component.vhdl
      begin: |
        (?x)
        # From the beginning of the line ...
        ^\s*
        
        # The word component $1
        \b((?i:component))\s+
        
        # A valid identifier $3 or invalid identifier $4
        (([a-zA-Z_][a-zA-Z0-9_]*)\s*|(.+?))(?=\b(?i:is|port)\b|$|--)
        
        # Optional word is $6
        (\b((?i:is\b)))?
                  
      beginCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: entity.name.type.component.begin.vhdl}
        '4': {name: invalid.illegal.invalid.identifier.vhdl}
        '6': {name: keyword.language.vhdl}
      end: |
        (?x)
        # The word end $1
        \b((?i:end))\s+
        
        # The word component $3 or illegal word $4
        (((?i:component\b))|(.+?))(?=\s*|;)
        
        # Optional identifier $7 or illegal mismatched $8
        (\s+((\3)|(.+?)))?(?=\s*;)
                  
      endCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: keyword.language.vhdl}
        '4': {name: invalid.illegal.component.keyword.required.vhdl}
        '7': {name: entity.name.type.component.end.vhdl}
        '8': {name: invalid.illegal.mismatched.identifier.vhdl}
      patterns:
      - include: '#generic_list_pattern'
      - include: '#port_list_pattern'
      - include: '#comments'

  concurrent_statement:
    patterns:
    - include: '#function_definition_pattern'
    - include: '#procedure_definition_pattern'
    - include: '#component_pattern'
    - include: '#if_pattern'
    - include: '#process_pattern'
    - include: '#type_pattern'
    - include: '#record_pattern'
    - include: '#for_pattern'
    - include: '#entity_instantiation_pattern'
    - include: '#component_instantiation_pattern'
    - include: '#cleanup'

  constants_numeric:
    patterns:
    - name: constant.numeric.floating_point.vhdl
      match: \b([+\-]?[\d_]+\.[\d_]+([eE][+\-]?[\d_]+)?)(?=[^\w])
    - name: constant.numeric.quoted.base_pound_number_pound.vhdl
      match: \b\d+(#)[0-9a-hA-F_]+(#)(?=[^\w])
      captures:
        '1': {name: constant.numeric.quoted.quote.vhdl}
        '2': {name: constant.numeric.quoted.quote.vhdl}
    - name: constant.numeric.integer.vhdl
      match: \b[\d_]+([eE][\d_]+)?(?=[^\w])
    - name: constant.numeric.quoted.double.string.hex.vhdl
      match: ([xX]\")[0-9a-fA-F_uUxXzZwWlLhH\-]+(\")
      captures:
        '1': {name: constant.numeric.quoted.quote.vhdl}
        '2': {name: constant.numeric.quoted.quote.vhdl}
    - name: constant.numeric.quoted.double.string.octal.vhdl
      match: ([oO]\")[0-7_uUxXzZwWlLhH\-]+(\")
      captures:
        '1': {name: constant.numeric.quoted.quote.vhdl}
        '2': {name: constant.numeric.quoted.quote.vhdl}
    - name: constant.numeric.quoted.double.string.binary.vhdl
      match: ([bB]?\")[01_uUxXzZwWlLhH\-]+(\")
      captures:
        '1': {name: constant.numeric.quoted.quote.vhdl}
        '2': {name: constant.numeric.quoted.quote.vhdl}
    - name: constant.numeric.quoted.double.string.illegal.vhdl
      match: ([bBoOxX]".+?")
      captures:
        '1': {name: invalid.illegal.quoted.double.string.vhdl}
    - name: constant.numeric.quoted.single.std_logic
      match: "'[01uUxXzZwWlLhH\\-]'"

  control_patterns:
    patterns:
    - include: '#case_pattern'
    - include: '#if_pattern'
    - include: '#for_pattern'
    - include: '#while_pattern'

  entity_instantiation_pattern:
    patterns:
    - name: meta.block.entity_instantiation.vhdl
      begin: |
        (?x)
        # From the beginning of the line
        ^\s*
        
        # Component identifier or illegal identifier $1
        ([a-zA-Z][a-zA-Z0-9_]*)
        
        # Colon! $2
        \s*(:)\s*
        
        # Optional word use $4
        (((?i:use))\s+)?
        
        # Required word entity $5
        ((?i:entity))\s+
        
        # Optional library unit identifier $8 for invalid identifier $9 followed by a dot $10
        (
          (([a-zA-Z][a-zA-Z0-9_]*)|(.+?))
          (\.)
        )?
        
        # Entity name reference $12 or illegal identifier $13
        (([a-zA-Z][a-zA-Z0-9_]*)|(.+?))

        # Optional architecture elaboration
        (?:\s*
          # Open paren $14
          (\()\s*
        
          # Arch identifier $15 or invalid identifier $16
          (?i:([a-zA-Z][a-zA-Z0-9_]*)|(.+?))(?=\s*\))
        
          # Close paren $17
          \s*(\))
        )?
        
        # End check
        \s*
        (?:
          # a comment $18
          (--.*$)|
          # port or generic (lookahead, so that includes can process it)
          (?=(?i:port|generic).*$)|
          # invalid $19
          (.*?$)|
          # end of line
          (?:$)
        )
                  
      beginCaptures:
        '1': {name: entity.name.section.entity_instantiation.vhdl}
        '2': {name: punctuation.vhdl}
        '4': {name: keyword.language.vhdl}
        '5': {name: keyword.language.vhdl}
        '8': {name: entity.name.tag.library.reference.vhdl}
        '9': {name: invalid.illegal.invalid.identifier.vhdl}
        '10': {name: punctuation.vhdl}
        '12': {name: entity.name.tag.entity.reference.vhdl}
        '13': {name: invalid.illegal.invalid.identifier.vhdl}
        '14': {name: punctuation.vhdl}
        '15': {name: entity.name.tag.architecture.reference.vhdl}
        '16': {name: invalid.illegal.invalid.identifier.vhdl}
        '17': {name: punctuation.vhdl}
        '18': {name: comment.line.double-dash.vhdl}
        '19': {name: invalid.illegal.invalid.identifier.vhdl}
      end: ;
      endCaptures:
        '0': {name: punctuation.vhdl}
      patterns:
      - include: '#generic_map_pattern'
      - include: '#port_map_pattern'
      - include: '#cleanup'

  entity_pattern:
    patterns:
    - name: meta.block.entity.vhdl
      begin: |
        (?x)
        # From the beginning of the line ...
        ^\s*
        
        # The word entity $1
        ((?i:entity\b))\s+
        
        # The identifier $3 or an invalid identifier $4
        (([a-zA-Z][a-zA-Z\d_]*)|(.+?))(?=\s)
                  
      beginCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: entity.name.type.entity.begin.vhdl}
        '4': {name: invalid.illegal.invalid.identifier.vhdl}
      end: |
        (?x)
        
        # The word end $1
        \b((?i:end\b))
        
        # Optional word entity $3
        (\s+((?i:entity)))?
        
        # Optional identifier match $6 or indentifier mismatch $7
        (\s+((\3)|(.+?)))?
        
        # Make sure there is a semicolon following
        (?=\s*;)
                  
      endCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: keyword.language.vhdl}
        '6': {name: entity.name.type.entity.end.vhdl}
        '7': {name: invalid.illegal.mismatched.identifier.vhdl}
      patterns:
      - include: '#comments'
      - include: '#generic_list_pattern'
      - include: '#port_list_pattern'
      - include: '#cleanup'

  for_pattern:
    patterns:
    - name: meta.block.for.vhdl
      begin: |
        (?x)
        # From the beginning of the line
        ^\s*
        (
          # Check for an identifier $2
          ([a-zA-Z][a-zA-Z0-9_]*)
        
          # Followed by a colon $3
          \s*(:)\s*
        )?
        
        # Make sure the next word is not wait
        (?!(?i:wait\s*))
        
        # The for keyword $4
        \b((?i:for))\b
        
        # Make sure the next word is not all
        (?!\s*(?i:all))
        
                  
      beginCaptures:
        '2': {name: entity.name.tag.for.generate.begin.vhdl}
        '3': {name: punctuation.vhdl}
        '4': {name: keyword.language.vhdl}
      end: |
        (?x)
        # The word end $1
        \b((?i:end))\s+
        (
          # Followed by generate or loop $3
           ((?i:generate|loop))
        
          # But it really is required $4
          |(\S+)
        )\b
        
        # The matching identifier $7 or an invalid identifier $8
        (\s+((\2)|(.+?)))?
        
        # Only space and a semicolon left
        (?=\s*;)
                  
      endCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: keyword.language.vhdl}
        '4': {name: invalid.illegal.loop.or.generate.required.vhdl}
        '7': {name: entity.name.tag.for.generate.end.vhdl}
        '8': {name: invalid.illegal.mismatched.identifier.vhdl}
      patterns:
      - include: '#control_patterns'
      - include: '#entity_instantiation_pattern'
      - include: '#component_pattern'
      - include: '#component_instantiation_pattern'
      - include: '#process_pattern'
      - include: '#cleanup'

  function_definition_pattern:
    patterns:
    - name: meta.block.function_definition.vhdl
      begin: |
        (?x)
        # From the beginning of the line
        ^\s*
        
        # The word function $1
        ((?i:function))\s+
        
        (
          # A valid normal identifier $3
           ([a-zA-Z][a-zA-Z\d_]*)
          # A valid string quoted identifier $4
          |("\S+")
          # A valid backslash escaped identifier $5
          |(\\.+\\)
          # An invalid identifier $5
          |(.+?)
        )
        
        # Check to make sure we have a list or we return
        (?=\s*
          (
             \(
            |(?i:\breturn\b)
          )
        )
                  
      beginCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: entity.name.function.function.begin.vhdl}
        '4': {name: entity.name.function.function.begin.vhdl}
        '5': {name: entity.name.function.function.begin.vhdl}
        '6': {name: invalid.illegal.invalid.identifier.vhdl}
      end: |
        (?x)
        # From the beginning of the line
        ^\s*
        
        # The word end $1
        ((?i:end))
        
        # Optional word function $3
        (\s+((?i:function)))?
        
        # Optional matched identifier $6 or mismatched identifier $7
        (\s+((\3|\4|\5)|(.+?)))?
        
        # Ending with whitespace and semicolon
        (?=\s*;)
                  
      endCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: keyword.language.vhdl}
        '6': {name: entity.name.function.function.end.vhdl}
        '7': {name: invalid.illegal.mismatched.identifier.vhdl}
      patterns:
      - include: '#control_patterns'
      - include: '#parenthetical_list'
      - include: '#type_pattern'
      - include: '#record_pattern'
      - include: '#cleanup'
  function_prototype_pattern:
    patterns:
    - name: meta.block.function_prototype.vhdl
      begin: |
        (?x)
        # From the beginning of the line
        ^\s*
        
        # The word function $1
        ((?i:function))\s+
        
        
        (
          # A valid normal identifier $3
           ([a-zA-Z][a-zA-Z\d_]*)
          # A valid quoted identifier $4
          |("\S+")
          # A valid backslash escaped identifier $5
          |(\\.+\\)
          # An invalid identifier $6
          |(.+?)
        )
        
        # Check to make sure we have a list or we return
        (?=\s*
          (
             \(
            |(?i:\breturn\b)
          )
        )
                  
      beginCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: entity.name.function.function.prototype.vhdl}
        '4': {name: entity.name.function.function.prototype.vhdl}
        '5': {name: entity.name.function.function.prototype.vhdl}
        '6': {name: invalid.illegal.function.name.vhdl}
      end: (?<=;)
      patterns:
      - begin: \b(?i:return)(?=\s+[^;]+\s*;)
        beginCaptures:
          '0': {name: keyword.language.vhdl}
        end: \;
        endCaptures:
          '0': {name: punctuation.terminator.function_prototype.vhdl}
        patterns:
        - include: '#parenthetical_list'
        - include: '#cleanup'
      - include: '#parenthetical_list'
      - include: '#cleanup'
  generic_list_pattern:
    patterns:
    - name: meta.block.generic_list.vhdl
      begin: \b(?i:generic)\b
      beginCaptures:
        '0': {name: keyword.language.vhdl}
      end: ;
      endCaptures:
        '0': {name: punctuation.vhdl}
      patterns:
      - include: '#parenthetical_list'
  generic_map_pattern:
    patterns:
    - name: meta.block.generic_map.vhdl
      begin: \b(?i:generic map)\b
      beginCaptures:
        '0': {name: keyword.language.vhdl}
      end: (?<=\))
      #|(\))
      endCaptures:
        '1': {name: invalid.illegal.unexpected.parenthesis.vhdl}
      patterns:
      - include: '#association_list'
  if_pattern:
    patterns:
    - name: meta.block.if.vhdl
      begin: |
        (?x)
        (
          # Optional identifier $2
          ([a-zA-Z][a-zA-Z0-9_]*)
        
          # Followed by a colon $3
          \s*(:)\s*
        )?
        
        # Keyword if $4
        \b((?i:if))\b
                  
      beginCaptures:
        '2': {name: entity.name.tag.if.generate.begin.vhdl}
        '3': {name: punctuation.vhdl}
        '4': {name: keyword.language.vhdl}
      end: |
        (?x)
        # The word end $1
        \b((?i:end))\s+
        
        (
          (
            # Optional generate or if keyword $4
             ((?i:generate|if))
        
            # Keyword if or generate required $5
            |(\S+)
          )\b
          (
            \s+
            (
              # Optional matching identifier $8
               (\2)
        
              # Mismatched identifier $9
              |(.+?)
            )
          )?
        )?
        
        # Followed by a semicolon
        (?=\s*;)
                  
      endCaptures:
        '1': {name: keyword.language.vhdl}
        '4': {name: keyword.language.vhdl}
        '5': {name: invalid.illegal.if.or.generate.required.vhdl}
        '8': {name: entity.name.tag.if.generate.end.vhdl}
        '9': {name: invalid.illegal.mismatched.identifier.vhdl}
      patterns:
      - include: '#control_patterns'
      - include: '#process_pattern'
      - include: '#entity_instantiation_pattern'
      - include: '#component_pattern'
      - include: '#component_instantiation_pattern'
      - include: '#cleanup'
  keywords:
    patterns:
    - name: keyword.attributes.vhdl
      match: "'(?i:active|ascending|base|delayed|driving|event|high|image|instance|instance_name|last|last_value|left|leftof|length|low|path|path_name|pos|pred|quiet|range|reverse|reverse_range|right|rightof|simple|simple_name|stable|succ|transaction|val|value)\\b"
    - name: keyword.language.vhdl
      match: \b(?i:abs|access|after|alias|all|and|architecture|array|assert|attribute|begin|block|body|buffer|bus|case|component|configuration|constant|disconnect|downto|else|elsif|end|entity|exit|file|for|function|generate|generic|group|guarded|if|impure|in|inertial|inout|is|label|library|linkage|literal|loop|map|mod|nand|new|next|nor|not|null|of|on|open|or|others|out|package|port|postponed|procedure|process|pure|range|record|register|reject|rem|report|return|rol|ror|select|severity|shared|signal|sla|sll|sra|srl|subtype|then|to|transport|type|unaffected|units|until|use|variable|wait|when|while|with|xnor|xor)\b
    - name: keyword.operator.vhdl
      match: (\+|\-|<=|=|=>|:=|>=|>|<|/|\||&|(\*{1,2}))
  package_body_pattern:
    patterns:
    - name: meta.block.package_body.vhdl
      begin: |
        (?x)
        # The word package $1
        \b((?i:package))\s+
        
        # ... but we want to be a package body $2
        ((?i:body))\s+
        
        # The valid identifier $4 or the invalid one $5
        (([a-zA-Z][a-zA-Z\d_]*)|(.+?))\s+
        
        # ... and we end it with an is $6
        ((?i:is))\b
                  
      beginCaptures:
        '1': {name: keyword.language.vhdl}
        '2': {name: keyword.language.vhdl}
        '4': {name: entity.name.section.package_body.begin.vhdl}
        '5': {name: invalid.illegal.invalid.identifier.vhdl}
        '6': {name: keyword.language.vhdl}
      end: |
        (?x)
        # The word end $1
        \b((?i:end\b))
        
        # Optional word package $3 body $4
        (\s+((?i:package))\s+((?i:body)))?
        
        # Optional identifier $7 or mismatched identifier $8
        (\s+((\4)|(.+?)))?(?=\s*;)
      endCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: keyword.language.vhdl}
        '4': {name: keyword.language.vhdl}
        '7': {name: entity.name.section.package_body.end.vhdl}
        '8': {name: invalid.illegal.mismatched.identifier.vhdl}
      patterns:
      - include: '#function_definition_pattern'
      - include: '#procedure_definition_pattern'
      - include: '#type_pattern'
      - include: '#subtype_pattern'
      - include: '#record_pattern'
      - include: '#cleanup'
  package_pattern:
    patterns:
    - name: meta.block.package.vhdl
      begin: |
        (?x)
        # The word package $1
        \b((?i:package))\s+
        
        # ... but we do not want to be a package body
        (?!(?i:body))
        
        # The valid identifier $3 or the invalid one $4
        (([a-zA-Z][a-zA-Z\d_]*)|(.+?))\s+
        
        # ... and we end it with an is $5
        ((?i:is))\b
                  
      beginCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: entity.name.section.package.begin.vhdl}
        '4': {name: invalid.illegal.invalid.identifier.vhdl}
        '5': {name: keyword.language.vhdl}
      end: |
        (?x)
        # The word end $1
        \b((?i:end\b))
        
        # Optional word package $3
        (\s+((?i:package)))?
        
        # Optional identifier $6 or mismatched identifier $7
        (\s+((\2)|(.+?)))?(?=\s*;)
      endCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: keyword.language.vhdl}
        '6': {name: entity.name.section.package.end.vhdl}
        '7': {name: invalid.illegal.mismatched.identifier.vhdl}
      patterns:
      - include: '#function_prototype_pattern'
      - include: '#procedure_prototype_pattern'
      - include: '#type_pattern'
      - include: '#subtype_pattern'
      - include: '#record_pattern'
      - include: '#component_pattern'
      - include: '#cleanup'
  parenthetical_list:
    patterns:
    - name: meta.block.parenthetical_list.vhdl
      begin: \(
      beginCaptures:
        '0': {name: punctuation.vhdl}
      end: (?<=\))
      patterns:
      - name: meta.list.element.vhdl
        begin: (?=['"a-zA-Z0-9])
        end: (;|\)|,)
        endCaptures:
          '1': {name: punctuation.vhdl}
        patterns:
        - include: '#comments'
        - include: '#parenthetical_pair'
        - include: '#cleanup'
      - name: invalid.illegal.unexpected.parenthesis.vhdl
        match: \)
      - include: '#cleanup'
  parenthetical_pair:
    patterns:
    - name: meta.block.parenthetical_pair.vhdl
      begin: \(
      beginCaptures:
        '0': {name: punctuation.vhdl}
      end: \)
      endCaptures:
        '0': {name: punctuation.vhdl}
      patterns:
      - include: '#parenthetical_pair'
      - include: '#cleanup'
  port_list_pattern:
    patterns:
    - name: meta.block.port_list.vhdl
      begin: \b(?i:port)\b
      beginCaptures:
        '0': {name: keyword.language.vhdl}
      end: ;
      endCaptures:
        '0': {name: punctuation.vhdl}
      patterns:
      - include: '#parenthetical_list'
  port_map_pattern:
    patterns:
    - name: meta.block.port_map.vhdl
      begin: \b(?i:port map)\b
      beginCaptures:
        '0': {name: keyword.language.vhdl}
      end: (?<=\))
      #|(\))
      endCaptures:
        '1': {name: invalid.illegal.unexpected.parenthesis.vhdl}
      patterns:
      - include: '#association_list'
  procedure_definition_pattern:
    patterns:
    - name: meta.block.procedure_definition.vhdl
      begin: |
        (?x)
        # From the beginning of the line
        ^\s*
        
        # The word function $1
        ((?i:procedure))\s+
        
        (
          # A valid normal identifier $3
           ([a-zA-Z][a-zA-Z\d_]*)
          # A valid quoted identifier $4
          |("\S+")
          # An invalid identifier $5
          |(.+?)
        )
        
        # Check to make sure we have a list is
        (?=\s*(\(|(?i:is)))
                  
      beginCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: entity.name.function.procedure.begin.vhdl}
        '4': {name: entity.name.function.procedure.begin.vhdl}
        '5': {name: invalid.illegal.invalid.identifier.vhdl}
      end: |
        (?x)
        # From the beginning of the line
        ^\s*
        
        # The word end $1
        ((?i:end))
        
        # Optional word function $3
        (\s+((?i:procedure)))?
        
        # Optional matched identifier $6 or mismatched identifier $7
        (\s+((\3|\4)|(.+?)))?
        
        # Ending with whitespace and semicolon
        (?=\s*;)
                  
      endCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: keyword.language.vhdl}
        '6': {name: entity.name.function.procedure.end.vhdl}
        '7': {name: invalid.illegal.mismatched.identifier.vhdl}
      patterns:
      - include: '#parenthetical_list'
      - include: '#control_patterns'
      - include: '#type_pattern'
      - include: '#record_pattern'
      - include: '#cleanup'
  procedure_prototype_pattern:
    patterns:
    - name: meta.block.procedure_prototype.vhdl
      begin: |
        (?x)
        \b((?i:procedure))\s+
        (([a-zA-Z][a-zA-Z0-9_]*)|(.+?))
        (?=\s*(\(|;))
                  
      beginCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: entity.name.function.procedure.begin.vhdl}
        '4': {name: invalid.illegal.invalid.identifier.vhdl}
      end: ;
      endCaptures:
        '0': {name: punctual.vhdl}
      patterns:
      - include: '#parenthetical_list'
  process_pattern:
    patterns:
    - name: meta.block.process.vhdl
      begin: |
        (?x)
        # From the beginning of the line
        ^\s*
        
        (
          # Optional identifier $2
          ([a-zA-Z][a-zA-Z0-9_]*)
        
          # Colon $3
          \s*(:)\s*
        )?
        
        # The word process #4
        ((?i:process\b))
                  
      beginCaptures:
        '2': {name: entity.name.section.process.begin.vhdl}
        '3': {name: punctuation.vhdl}
        '4': {name: keyword.language.vhdl}
      end: |
        (?x)
        # The word end $1
        ((?i:end))
        
        # Optional word process $3
        (\s+((?i:process)))
        
        # Optional identifier $6 or invalid identifier $7
        (\s+((\2)|(.+?)))?
        
        (?=\s*;)
                  
      endCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: keyword.language.vhdl}
        '6': {name: entity.name.section.process.end.vhdl}
        '7': {name: invalid.illegal.invalid.identifier.vhdl}
      patterns:
      - include: '#control_patterns'
      - include: '#cleanup'
  punctuation:
    patterns:
    - name: punctuation.vhdl
      match: (\.|,|:|;|\(|\))
  record_pattern:
    patterns:
    - name: meta.block.record.vhdl
      begin: \b(?i:record)\b
      beginCaptures:
        '0': {name: keyword.language.vhdl}
      end: |
        (?x)
        # The word end $1
        \b((?i:end))
        
        # The word record $2
        \s+((?i:record))
        
        # Optional identifier $5 or invalid identifier $6
        (\s+(([a-zA-Z][a-zA-Z\d_]*)|(.*?)))?
        
        # Only whitespace and semicolons can be left
        (?=\s*;)
                  
      endCaptures:
        '1': {name: keyword.language.vhdl}
        '2': {name: keyword.language.vhdl}
        '5': {name: entity.name.type.record.vhdl}
        '6': {name: invalid.illegal.invalid.identifier.vhdl}
      patterns:
      - include: '#cleanup'
    - include: '#cleanup'
  strings:
    patterns:
    - name: string.quoted.single.vhdl
      match: "'.'"
    - name: string.quoted.double.vhdl
      begin: '"'
      end: '"'
      patterns:
      - name: constant.character.escape.vhdl
        match: \\.
    - name: string.other.backslash.vhdl
      begin: \\
      end: \\
  subtype_pattern:
    patterns:
    - name: meta.block.subtype.vhdl
      begin: |
        (?x)
        # The word subtype $1
        \b((?i:subtype))\s+
        
        # Valid identifier $3 or invalid identifier $4
        (([a-zA-Z][a-zA-Z0-9_]*)|(.+?))\s+
        
        # The word is $5
        ((?i:is))\b
                  
      beginCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: entity.name.type.subtype.vhdl}
        '4': {name: invalid.illegal.invalid.identifier.vhdl}
        '5': {name: keyword.language.vhdl}
      end: ;
      endCaptures:
        '0': {name: punctuation.vhdl}
      patterns:
      - include: '#cleanup'
  support_constants:
    patterns:
    - name: support.constant.ieee.math_real.vhdl
      match: \b(?i:math_1_over_e|math_1_over_pi|math_1_over_sqrt_2|math_2_pi|math_3_pi_over_2|math_deg_to_rad|math_e|math_log10_of_e|math_log2_of_e|math_log_of_10|math_log_of_2|math_pi|math_pi_over_2|math_pi_over_3|math_pi_over_4|math_rad_to_deg|math_sqrt_2|math_sqrt_pi)\b
    - name: support.constant.ieee.math_complex.vhdl
      match: \b(?i:math_cbase_1|math_cbase_j|math_czero|positive_real|principal_value)\b
    - name: support.constant.std.standard.vhdl
      match: \b(?i:true|false)\b
  support_functions:
    patterns:
    - name: support.function.std.env.vhdl
      match: \b(?i:finish|stop|resolution_limit)\b
    - name: support.function.std.textio.vhdl
      match: \b(?i:readline|read|writeline|write|endfile|endline)\b
    - name: support.function.ieee.std_logic_1164.vhdl
      match: \b(?i:rising_edge|falling_edge|to_bit|to_bitvector|to_stdulogic|to_stdlogicvector|to_stdulogicvector|is_x)\b
    - name: support.function.ieee.numeric_std.vhdl
      match: \b(?i:shift_left|shift_right|rotate_left|rotate_right|resize|to_integer|to_unsigned|to_signed)\b
    - name: support.function.ieee.math_real.vhdl
      match: \b(?i:arccos(h?)|arcsin(h?)|arctan|arctanh|cbrt|ceil|cos|cosh|exp|floor|log10|log2|log|realmax|realmin|round|sign|sin|sinh|sqrt|tan|tanh|trunc)\b
    - name: support.function.ieee.math_complex.vhdl
      match: \b(?i:arg|cmplx|complex_to_polar|conj|get_principal_value|polar_to_complex)\b
  support_types:
    patterns:
    - name: support.type.std.standard.vhdl
      match: \b(?i:boolean|bit|character|severity_level|integer|real|time|delay_length|now|natural|positive|string|bit_vector|file_open_kind|file_open_status|fs|ps|ns|us|ms|sec|min|hr|severity_level|note|warning|error|failure)\b
    - name: support.type.std.textio.vhdl
      match: \b(?i:line|text|side|width|input|output)\b
    - name: support.type.ieee.std_logic_1164.vhdl
      match: \b(?i:std_logic|std_ulogic|std_logic_vector|std_ulogic_vector)\b
    - name: support.type.ieee.numeric_std.vhdl
      match: \b(?i:signed|unsigned)\b
    - name: support.type.ieee.math_complex.vhdl
      match: \b(?i:complex|complex_polar)\b
  syntax_highlighting:
    patterns:
    - include: '#keywords'
    - include: '#punctuation'
    - include: '#support_constants'
    - include: '#support_types'
    - include: '#support_functions'
  type_pattern:
    patterns:
    - name: meta.block.type.vhdl
      begin: |
        (?x)
        # The word type $1
        \b((?i:type))\s+
        
        # Valid identifier $3 or invalid identifier $4
        (([a-zA-Z][a-zA-Z0-9_]*)|(.+?))
        
        (
          # A semicolon is coming up if we are incomplete
           (?=\s*;)
        
          # Or the word is comes up $7
          |(\s+((?i:is)))
        )\b
                  
      beginCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: entity.name.type.type.vhdl}
        '4': {name: invalid.illegal.invalid.identifier.vhdl}
        '7': {name: keyword.language.vhdl}
      end: ;
      endCaptures:
        '0': {name: punctuation.vhdl}
      patterns:
      - include: '#record_pattern'
      - include: '#cleanup'
  variable_pattern:
    patterns:
    - name: variable.vhdl
      match: ([a-zA-Z][a-zA-Z0-9_]*)
  while_pattern:
    patterns:
    - name: meta.block.while.vhdl
      begin: |
        (?x)
        # From the beginning of the line
        ^\s*
        (
          # Check for an identifier $2
          ([a-zA-Z][a-zA-Z0-9_]*)
        
          # Followed by a colon $3
          \s*(:)\s*
        )?
        
        # The for keyword $4
        \b((?i:while))\b
                  
      beginCaptures:
        '2': {name: ''}
        '3': {name: punctuation.vhdl}
        '4': {name: keyword.language.vhdl}
      end: |
        (?x)
        # The word end $1
        \b((?i:end))\s+
        (
          # Followed by keyword loop $3
           ((?i:loop))
        
          # But it really is required $4
          |(\S+)
        )\b
        
        # The matching identifier $7 or an invalid identifier $8
        (\s+((\2)|(.+?)))?
        
        # Only space and a semicolon left
        (?=\s*;)
                  
      endCaptures:
        '1': {name: keyword.language.vhdl}
        '3': {name: keyword.language.vhdl}
        '4': {name: invalid.illegal.loop.keyword.required.vhdl}
        '7': {name: entity.name.tag.while.loop.vhdl}
        '8': {name: invalid.illegal.mismatched.identifier}
      patterns:
      - include: '#control_patterns'
      - include: '#cleanup'
foldingStartMarker: |
  (?x)
  # From the start of the line make sure we are not going into a comment ...
  ^(
    ([^-]-?(?!-))*?
      (
      # Check for "keyword ... is"
       (\b(?i:architecture|case|entity|function|package|procedure)\b(.+?)(?i:\bis)\b)

      # Check for if statements
      |(\b(?i:if)\b(.+?)(?i:generate|then)\b)

      # Check for and while statements
      |(\b(?i:for|while)(.+?)(?i:loop|generate)\b)

      # Check for keywords that do not require an is after it
      |(\b(?i:component|process|record)\b[^;]*?$)

      # From the beginning of the line, check for instantiation maps
      |(^\s*\b(?i:port|generic)\b(?i:\s+map\b)?\s*\()
    )
  )
foldingStopMarker: |
  (?x)
  # From the start of the line ...
  ^(
    (
      (
        # Make sure we are not going into a comment ...
        ([^-]-?(?!-))*?
          (
            # The word end to the end of the line
            (?i:\bend\b).*$\n?
          )
        )
      )

      # ... a close paren followed by an optional semicolon as the only thing on the line
        |(\s*?\)\s*?;?\s*?$\n?
    )
  )
keyEquivalent: ^~V
